from __future__ import annotations

from typing import Any, Callable, Generic, TypedDict, TypeVar, cast

from typing_extensions import ParamSpec

from polyfactory.exceptions import MissingParamException, ParameterException

T = TypeVar("T")
U = TypeVar("U")
P = ParamSpec("P")


class WrappedCallable(TypedDict):
    """A ref storing a callable. This class is a utility meant to prevent binding of methods."""

    value: Callable


class Require:
    """A factory field that marks an attribute as a required build-time kwarg."""


class Ignore:
    """A factory field that marks an attribute as ignored."""


class Use(Generic[P, T]):
    """Factory field used to wrap a callable.

    The callable will be invoked whenever building the given factory attribute.


    """

    __slots__ = ("args", "fn", "kwargs")

    def __init__(self, fn: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> None:
        """Wrap a callable.

        :param fn: A callable to wrap.
        :param args: Any args to pass to the callable.
        :param kwargs: Any kwargs to pass to the callable.
        """
        self.fn: WrappedCallable = {"value": fn}
        self.kwargs = kwargs
        self.args = args

    def to_value(self) -> T:
        """Invoke the callable.

        :returns: The output of the callable.


        """
        return cast("T", self.fn["value"](*self.args, **self.kwargs))


class PostGenerated:
    """Factory field that allows generating values after other fields are generated by the factory."""

    __slots__ = ("args", "fn", "kwargs")

    def __init__(self, fn: Callable, *args: Any, **kwargs: Any) -> None:
        """Designate field as post-generated.

        :param fn: A callable.
        :param args: Args for the callable.
        :param kwargs: Kwargs for the callable.
        """
        self.fn: WrappedCallable = {"value": fn}
        self.kwargs = kwargs
        self.args = args

    def to_value(self, name: str, values: dict[str, Any]) -> Any:
        """Invoke the post-generation callback passing to it the build results.

        :param name: Field name.
        :param values: Generated values.

        :returns: An arbitrary value.
        """
        return self.fn["value"](name, values, *self.args, **self.kwargs)


class Fixture:
    """Factory field to create a pytest fixture from a factory."""

    __slots__ = ("kwargs", "ref", "size")

    def __init__(self, fixture: Callable, size: int | None = None, **kwargs: Any) -> None:
        """Create a fixture from a factory.

        :param fixture: A factory that was registered as a fixture.
        :param size: Optional batch size.
        :param kwargs: Any build kwargs.
        """
        self.ref: WrappedCallable = {"value": fixture}
        self.size = size
        self.kwargs = kwargs

    def to_value(self) -> Any:
        """Call the factory's build or batch method.

        :raises: ParameterException

        :returns: The build result.
        """
        from polyfactory.pytest_plugin import FactoryFixture

        if factory := FactoryFixture.factory_class_map.get(self.ref["value"]):
            if self.size is not None:
                return factory.batch(self.size, **self.kwargs)
            return factory.build(**self.kwargs)

        msg = "fixture has not been registered using the register_factory decorator"
        raise ParameterException(msg)


class NotPassed:
    """Indicates a parameter was not passed to a factory field and must be
    passed at build time.
    """


IsNotPassed = NotPassed()


class BaseParam(Generic[T, U]):
    """Base class for parameters.

    This class is used to pass a parameters that can be referenced by other
    fields but will not be passed to the final object.

    It is generic over the type of the parameter that will be used during build
    and also the method used to generate that value (e.g. as a constant or a
    callable).
    """

    def to_value(self, from_build: U | NotPassed = IsNotPassed) -> T:
        """Determines the value of the parameter.

        This method must be implemented in subclasses.

        :param from_build: The value passed at build time.
        :returns: The value
        :raises: NotImplementedError
        """
        msg = "to_value must be implemented in subclasses"
        raise NotImplementedError(msg)  # pragma: no cover


class Param(Generic[T], BaseParam[T, T]):
    """A constant parameter that can be used by other fields but will not be
    passed to the final object.

    If a value for the parameter is not passed in the field's definition, it must
    be passed at build time. Otherwise, a MissingParamException will be raised.
    """

    __slots__ = ("param",)

    def __init__(self, param: T | NotPassed = IsNotPassed) -> None:
        """Designate a parameter.

        :param param: A constant or an unpassed value that can be referenced later
        """
        self.param = param

    def to_value(self, from_build: T | NotPassed = IsNotPassed) -> T:
        """Determines the value to use at build time

        If a value was passed to the constructor, it will be used. Otherwise, the value
        passed at build time will be used. If no value was passed at build time, a
        MissingParamException will be raised.

        :param args: from_build: The value passed at build time (if any).
        :returns: The value
        :raises: MissingParamException
        """
        if self.param is IsNotPassed:
            if from_build is not IsNotPassed:
                return cast(T, from_build)
            msg = "Param value was not passed at build time"
            raise MissingParamException(msg)
        return cast(T, self.param)


class CallableParam(Generic[T], BaseParam[T, Callable[..., T]]):
    """A callable parameter that can be used by other fields but will not be
    passed to the final object.

    The callable may be passed optional keyword arguments via the constructor
    of this class. The callable will be invoked with the passed keyword
    arguments and any positional arguments passed at build time.

    If a callable for the parameter is not passed in the field's definition, it must
    be passed at build time. Otherwise, a MissingParamException will be raised.
    """

    __slots__ = (
        "kwargs",
        "param",
    )

    def __init__(
        self,
        param: Callable[..., T] | NotPassed = IsNotPassed,
        **kwargs: Any,
    ) -> None:
        """Designate field as a callable parameter.

        :param param: A callable that will be evaluated at build time.
        :param kwargs: Any kwargs to pass to the callable.
        """
        self.param = param
        self.kwargs = kwargs

    def to_value(self, from_build: Callable[..., T] | NotPassed = IsNotPassed) -> T:
        """Determine the value to use at build time.

        If a value was passed to the constructor, it will be used. Otherwise, the value
        passed at build time will be used. If no value was passed at build time, a
        MissingParamException will be raised.

        :param args: from_build: The callable passed at build time (if any).
        :returns: The value
        :raises: MissingParamException
        """
        if self.param is IsNotPassed:
            if from_build is not IsNotPassed:
                return cast(Callable[..., T], from_build)(**self.kwargs)
            msg = "Param value was not passed at build time"
            raise MissingParamException(msg)
        return cast(Callable[..., T], self.param)(**self.kwargs)
